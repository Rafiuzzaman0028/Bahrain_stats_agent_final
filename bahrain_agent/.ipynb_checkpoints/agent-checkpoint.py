# -*- coding: utf-8 -*-
"""agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ric0LVcuLkYbUAIaFxT6e0BCNAE8WRjZ
"""

"""
agent.py

High-level BahrainStatsAgent that:
- Holds a DataRepository
- Uses NLU router to understand questions
- Uses describe_layer to generate human-readable answers
"""

from typing import Optional

from .data_layer import load_all_data, DataRepository
from .describe_layer import (
    describe_labour_market,
    describe_governorates,
    describe_housing_units,
    describe_students,
    describe_teachers,
    describe_higher_education,
)
from .nlu_router import classify_intent, extract_year


class BahrainStatsAgent:
    """
    Main public interface for the Bahrain Statistical AI Agent.

    Typical usage:
        agent = BahrainStatsAgent(data_path="data/bahrain_master")
        answer = agent.answer_question("Summarize the labour market in 2022")
    """

    def __init__(self, data_path: str = "data/bahrain_master"):
        self.data_path = data_path
        self.repo: DataRepository = load_all_data(data_path)

    # Optional helper if you ever want to reload the data without restarting Python
    def refresh_data(self):
        """Reload CSVs from disk into the DataRepository."""
        self.repo = load_all_data(self.data_path)

    def _get_default_year(self) -> Optional[int]:
        """
        Try to infer a sensible default year from labour_master;
        if not available, from any other dataset that has a 'year' column.
        """
        for df in [
            self.repo.labour_master,
            self.repo.occupation_workers,
            self.repo.households,
            self.repo.population_density,
            self.repo.housing_units,
            self.repo.students,
            self.repo.teachers,
            self.repo.higher_education,
        ]:
            if not df.empty and "year" in df.columns:
                try:
                    return int(df["year"].max())
                except Exception:
                    continue
        return None

    def answer_question(self, question: str) -> str:
        """
        Main method: takes a natural language question and returns a textual answer.
        """
        intent = classify_intent(question)
        default_year = self._get_default_year()
        year = extract_year(question, default_year)

        # Route based on intent
        if intent == "labour_overview":
            return describe_labour_market(self.repo, year)
        elif intent == "top_occupations":
            return describe_labour_market(self.repo, year)  # could be specialised later
        elif intent == "households":
            return describe_governorates(self.repo)
        elif intent == "density":
            return describe_governorates(self.repo)
        elif intent == "housing_units":
            return describe_housing_units(self.repo)
        elif intent == "students":
            return describe_students(self.repo)
        elif intent == "teachers":
            return describe_teachers(self.repo)
        elif intent == "higher_education":
            return describe_higher_education(self.repo)
        else:
            # Fallback generic help
            help_text = [
                "I didn't fully understand that question, but here is what I can do:",
                "",
                "- Summarize the labour market in a given year",
                "- Show most common occupations",
                "- Describe households and population density by governorate",
                "- Summarize housing units",
                "- Give an overview of students and teachers",
                "- Describe higher education students",
                "",
                "Try asking, for example:",
                "- 'Summarize the labour market in 2022'",
                "- 'What are the most common occupations?'",
                "- 'Describe households and population density by governorate'",
                "- 'Give an overview of higher education students'",
            ]
            return "\n".join(help_text)

